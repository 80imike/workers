<!doctype html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8" />

    <title>Netnr status</title>
    <link rel="icon" href="favicon.ico">

    <!-- https://github.com/netnr/workers -->
    <script>
        /*
        * nrcUptimeRobot - Static status page renderer based on UptimeRobot API
        * 
        *   nrcUptimeRobot.init({
        *     apiKey: 'your_uptimerobot_api_key',
        *     title: 'Service status',
        *     logo: 'favicon.ico',
        *     link: '/',
        *     container: 'body',
        *     uptimeDays: 90,
        *     pollInterval: 0,
        *     hideKeywordMonitoring: [],
        *   });
        */

        class nrcUptimeRobot {
            static _opts = null;
            static _timer = null;
            static _styleInjected = false;

            /**
            * Default configuration options
            */
            static defaultOptions() {
                return {
                    apiKey: '',
                    container: 'body',
                    title: 'Service status',
                    logo: '',
                    link: '',
                    pollInterval: 0, // Poll interval in seconds, 0 means no polling
                    uptimeDays: 90, // Display recent days status
                    endpoint: 'https://api.uptimerobot.com/v2/getMonitors',
                    timeout: 15000,
                    // Custom fetch function (for proxy or debugging)
                    fetchImpl: null,
                    hideKeywordMonitoring: []
                };
            }

            /**
            * Initialize status page
            */
            static init(options = {}) {
                this._opts = Object.assign(this.defaultOptions(), options || {});

                // Validate required parameters
                if (!this._opts.apiKey) {
                    console.error('nrcUptimeRobot: apiKey is required');
                    this._renderError('Configuration error: UptimeRobot API Key is required');
                    return;
                }

                const container = this._resolveContainer(this._opts.container);
                if (!container) {
                    console.error('nrcUptimeRobot: container not found');
                    this._renderError('Container not found: ' + this._opts.container);
                    return;
                }

                // Inject styles
                this._createStyle();

                // Render shell structure
                this._renderShell(container);

                // Load data for the first time
                this._fetchAndRender();

                // Setup polling
                if (this._opts.pollInterval && this._opts.pollInterval > 0) {
                    if (this._timer) clearInterval(this._timer);
                    this._timer = setInterval(() => this._fetchAndRender(), this._opts.pollInterval * 1000);
                }
            }

            /**
            * Destroy instance
            */
            static destroy() {
                if (this._timer) {
                    clearInterval(this._timer);
                    this._timer = null;
                }

                // Clean up responsive grid listeners
                if (this._resizeHandler) {
                    window.removeEventListener('resize', this._resizeHandler);
                    this._resizeHandler = null;
                }

                if (this._resizeObserver) {
                    this._resizeObserver.disconnect();
                    this._resizeObserver = null;
                }
            }

            /**
            * Resolve container element
            */
            static _resolveContainer(c) {
                if (typeof c === 'string') return document.querySelector(c);
                if (c instanceof Element) return c;
                return document.body;
            }

            /**
            * Create and inject styles
            */
            static _createStyle() {
                if (this._styleInjected || document.getElementById('nrc-uptimerobot-style')) return;

                const css = `
        /* nrcUptimeRobot status page styles */
        .nrc-uptime-wrap {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            color: #1f2937;
            line-height: 1.5;
            min-height: 200px;
        }

        .nrc-uptime-header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 24px 0;
            margin-bottom: 32px;
        }

        .nrc-uptime-header-link,
        .nrc-uptime-header-content {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .nrc-uptime-header-link {
            text-decoration: none;
            color: inherit;
            transition: opacity 0.2s ease;
        }

        .nrc-uptime-header-link:hover {
            opacity: 0.8;
        }

        .nrc-uptime-logo {
            height: 48px;
            width: auto;
            border-radius: 8px;
            object-fit: contain;
        }

        .nrc-uptime-title {
            font-size: 32px;
            font-weight: 700;
            margin: 0;
            color: #111827;
        }

        .nrc-uptime-list {
            display: flex;
            flex-direction: column;
            gap: 0.5em;
        }

        .nrc-uptime-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 0.5em;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s ease;
        }

        .nrc-uptime-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .nrc-uptime-item:hover .nrc-uptime-grid-footer-right {
            display: flex;
            align-items: center;
        }

        .nrc-uptime-badge {
            padding: 0 6px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: white;
        }

        /* Badge colors */
        .nrc-uptime-badge.status-up { background-color: #10b981; }
        .nrc-uptime-badge.status-down { background-color: #ef4444; }
        .nrc-uptime-badge.status-paused { background-color: #9ca3af; }
        .nrc-uptime-badge.status-unknown { background-color: #6b7280; }

        .nrc-uptime-meta {
            font-size: 13px;
            color: #6b7280;
        }

        .nrc-uptime-service-name {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
            color: #111827;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nrc-uptime-service-link {
            display: inline-flex;
            align-items: center;
            text-decoration: none;
            color: #6b7280;
            transition: color 0.2s ease;
            opacity: 0.7;
        }

        .nrc-uptime-service-link:hover {
            color: #3b82f6;
            opacity: 1;
        }

        .nrc-uptime-service-link svg {
            width: 14px;
            height: 14px;
        }

        .nrc-uptime-grid-section {
            margin-top: 0;
        }

        .nrc-uptime-grid-header,
        .nrc-uptime-grid-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nrc-uptime-grid-header {
            margin-bottom: 0.5em;
        }

        .nrc-uptime-grid-footer {
            margin-top: 0.5em;
        }

        .nrc-uptime-grid-header-left,
        .nrc-uptime-grid-footer-left {
            display: flex;
            align-items: center;
        }

        .nrc-uptime-grid-header-left {
            gap: 12px;
            flex: 1;
        }

        .nrc-uptime-grid-header-right {
            display: flex;
            align-items: center;
        }
        .nrc-uptime-grid-footer-right {
            display: none;
        }

        .nrc-uptime-availability {
            text-align: right;
        }

        .nrc-uptime-availability-value {
            font-size: 16px;
            font-weight: 700;
            color: #111827;
            line-height: 1;
        }

        .nrc-uptime-time-label {
            font-size: 12px;
            color: #9ca3af;
            font-weight: 500;
        }

        .nrc-uptime-grid-legend {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #6b7280;
        }

        .nrc-uptime-grid-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .nrc-uptime-grid-legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .nrc-uptime-grid {
            display: grid;
            gap: 3px;
            max-width: 100%;
            justify-content: flex-start;
            width: 100%;
        }

        .nrc-uptime-cell {
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.1s ease;
            position: relative;
        }

        .nrc-uptime-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* Grid cell colors */
        .nrc-uptime-cell.day-up { background-color: #10b981; }
        .nrc-uptime-cell.day-partial { background-color: #f59e0b; }
        .nrc-uptime-cell.day-down { background-color: #ef4444; }
        .nrc-uptime-cell.day-empty { background-color: #e5e7eb; }
        .nrc-uptime-cell.day-paused { background-color: #9ca3af; }

        .nrc-uptime-empty {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
            font-size: 16px;
        }

        .nrc-uptime-error {
            color: #ef4444;
            background: #fef2f2;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #fecaca;
            margin: 20px;
        }

        .nrc-uptime-loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nrc-uptime-content {
            min-height: 200px;
        }

        .nrc-uptime-footer {
            text-align: center;
            padding: 32px 0 16px 0;
            margin-top: 32px;
        }

        .nrc-uptime-powered {
            font-size: 13px;
            color: #9ca3af;
            margin: 0;
            font-weight: 500;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .nrc-uptime-wrap {
                padding: 0 16px;
                margin: 16px auto;
            }
            
            .nrc-uptime-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            
            .nrc-uptime-item {
                padding: 0.5em;
            }
            
            .nrc-uptime-grid-header-left {
                gap: 8px;
                flex-wrap: wrap;
            }
            
            .nrc-uptime-grid-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .nrc-uptime-grid-footer {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }
            
            .nrc-uptime-grid-legend {
                gap: 12px;
                flex-wrap: wrap;
            }
            
            .nrc-uptime-grid-footer-right,
            .nrc-uptime-item:hover .nrc-uptime-grid-footer-right, 
            .nrc-uptime-availability-value {
                display: none;
            }
            
            .nrc-uptime-grid {
                gap: 2px;
            }
        }

        /* Tooltip styles */
        .nrc-uptime-tooltip {
            position: fixed;
            background: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            white-space: pre-line;
            max-width: 500px;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: translateZ(0);
            will-change: transform, opacity;
        }

        .nrc-uptime-tooltip.show {
            opacity: 1;
        }

        .nrc-uptime-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #1f2937;
        }
        `;

                const style = document.createElement('style');
                style.id = 'nrc-uptimerobot-style';
                style.appendChild(document.createTextNode(css));
                document.head.appendChild(style);

                this._styleInjected = true;
            }

            /**
            * Render shell structure
            */
            static _renderShell(container) {
                const shell = document.createElement('div');
                shell.className = 'nrc-uptime-wrap';

                const headerHtml = `
                    <div class="nrc-uptime-header">
                        ${this._opts.link ? `
                            <a class="nrc-uptime-header-link" href="${this._opts.link}" target="_blank" rel="noopener">
                                ${this._opts.logo ? `<img class="nrc-uptime-logo" src="${this._opts.logo}" alt="Logo">` : ''}
                                <h1 class="nrc-uptime-title">${this._escapeHtml(this._opts.title)}</h1>
                            </a>
                        ` : `
                            <div class="nrc-uptime-header-content">
                                ${this._opts.logo ? `<img class="nrc-uptime-logo" src="${this._opts.logo}" alt="Logo">` : ''}
                                <h1 class="nrc-uptime-title">${this._escapeHtml(this._opts.title)}</h1>
                            </div>
                        `}
                    </div>
                `;

                shell.innerHTML = headerHtml + '<div class="nrc-uptime-content"><div class="nrc-uptime-loading">Loading...</div></div>';

                // Replace or append to container
                const existing = container.querySelector('.nrc-uptime-wrap');
                if (existing) {
                    existing.replaceWith(shell);
                } else {
                    container.appendChild(shell);
                }
            }

            /**
            * Fetch data and render
            */
            static async _fetchAndRender() {
                const container = this._resolveContainer(this._opts.container);
                if (!container) return;

                const contentEl = container.querySelector('.nrc-uptime-content');
                if (!contentEl) return;

                try {
                    const data = await this._fetchMonitors();
                    this._renderMonitors(contentEl, data);
                } catch (error) {
                    console.error('nrcUptimeRobot fetch error:', error);
                    contentEl.innerHTML = `<div class="nrc-uptime-error">Loading failed: ${error.message}</div>`;
                }
            }

            /**
            * Fetch monitor data from UptimeRobot API
            */
            static async _fetchMonitors() {
                const body = new URLSearchParams();
                body.append('api_key', this._opts.apiKey);
                body.append('format', 'json');
                body.append('logs', '1');
                body.append('log_types', '1');

                // Request recent N days custom uptime ratio data
                if (this._opts.uptimeDays && Number(this._opts.uptimeDays) > 0) {
                    const days = Number(this._opts.uptimeDays);
                    const ranges = this._generateUptimeRanges(days);
                    if (ranges) {
                        body.append('custom_uptime_ranges', ranges);
                    }
                }

                const fetchImpl = this._opts.fetchImpl || window.fetch.bind(window);
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), this._opts.timeout);

                try {
                    const response = await fetchImpl(this._opts.endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Accept': 'application/json'
                        },
                        body: body.toString(),
                        signal: controller.signal,
                    });

                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const json = await response.json();

                    if (json.stat !== 'ok') {
                        throw new Error(`API Error: ${JSON.stringify(json)}`);
                    }

                    return json.monitors || [];
                } catch (error) {
                    clearTimeout(timeout);
                    throw error;
                }
            }

            /**
            * Generate uptime ranges string for API request
            * Format: startTimestamp_endTimestamp-startTimestamp_endTimestamp...
            */
            static _generateUptimeRanges(days) {
                try {
                    const ranges = [];
                    const now = new Date();

                    // Generate ranges for each day, from oldest to newest (time ascending)
                    // This matches the order of returned data from UptimeRobot API
                    for (let i = days - 1; i >= 0; i--) {
                        const endDate = new Date(now);
                        endDate.setDate(endDate.getDate() - i);
                        endDate.setHours(23, 59, 59, 999); // End of day

                        const startDate = new Date(endDate);
                        startDate.setHours(0, 0, 0, 0); // Start of day

                        const startTimestamp = Math.floor(startDate.getTime() / 1000);
                        const endTimestamp = Math.floor(endDate.getTime() / 1000);

                        ranges.push(`${startTimestamp}_${endTimestamp}`);
                    }

                    return ranges.join('-');
                } catch (error) {
                    console.warn('Failed to generate uptime ranges:', error);
                    return null;
                }
            }

            /**
            * Check if monitor should be hidden based on hideKeywordMonitoring
            */
            static _shouldHideMonitor(monitor) {
                if (!Array.isArray(this._opts.hideKeywordMonitoring) || this._opts.hideKeywordMonitoring.length === 0) {
                    return false;
                }

                const serviceName = monitor.friendly_name || monitor.url || '';

                return this._opts.hideKeywordMonitoring.some(keyword => {
                    if (typeof keyword !== 'string' || keyword.trim() === '') {
                        return false;
                    }
                    // Case-insensitive matching
                    return serviceName.toLowerCase().includes(keyword.toLowerCase().trim());
                });
            }

            /**
            * Render monitor list
            */
            static _renderMonitors(container, monitors) {
                if (!Array.isArray(monitors) || monitors.length === 0) {
                    container.innerHTML = '<div class="nrc-uptime-empty">No monitors found</div>';
                    return;
                }

                // Filter out hidden monitors based on hideKeywordMonitoring
                const visibleMonitors = monitors.filter(monitor => !this._shouldHideMonitor(monitor));

                if (visibleMonitors.length === 0) {
                    container.innerHTML = '<div class="nrc-uptime-empty">No monitors to display (all hidden by keywords filter)</div>';
                    return;
                }

                const list = document.createElement('div');
                list.className = 'nrc-uptime-list';

                visibleMonitors.forEach(monitor => {
                    const item = this._createMonitorItem(monitor);
                    list.appendChild(item);
                });

                container.innerHTML = '';
                container.appendChild(list);

                // Add footer information
                const footer = document.createElement('div');
                footer.className = 'nrc-uptime-footer';
                footer.innerHTML = '<p class="nrc-uptime-powered">Powered by UptimeRobot API</p>';
                container.appendChild(footer);

                // Add tooltip functionality
                this._initTooltips(container);

                // Initialize responsive grid
                this._initResponsiveGrid(container);
            }

            /**
            * Create monitor item element
            */
            static _createMonitorItem(monitor) {
                const item = document.createElement('div');
                item.className = 'nrc-uptime-item';

                // Build grid chart
                const { gridHtml } = this._createUptimeGrid(monitor);

                item.innerHTML = gridHtml;

                return item;
            }

            /**
            * Format date to yyyy-MM-dd HH:mm:ss format
            */
            static _formatDateTime(date, includeTime = true) {
                if (!(date instanceof Date)) {
                    date = new Date(date);
                }

                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');

                if (!includeTime) {
                    return `${year}-${month}-${day}`;
                }

                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');

                return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
            }

            /**
            * Process logs for a specific date range
            */
            static _processLogsForDate(logs, startDate, endDate) {
                if (!Array.isArray(logs)) return [];

                const startTimestamp = Math.floor(startDate.getTime() / 1000);
                const endTimestamp = Math.floor(endDate.getTime() / 1000);

                return logs.filter(log => {
                    const logStart = parseInt(log.datetime);
                    const logEnd = parseInt(log.datetime) + parseInt(log.duration || 0);

                    // Check if log overlaps with the date range
                    return (logStart >= startTimestamp && logStart <= endTimestamp) ||
                        (logEnd >= startTimestamp && logEnd <= endTimestamp) ||
                        (logStart <= startTimestamp && logEnd >= endTimestamp);
                });
            }

            /**
            * Format log information for tooltip
            */
            static _formatLogTooltip(logs, dateStr, ratio) {
                if (!Array.isArray(logs) || logs.length === 0) {
                    return ratio !== null ? `${dateStr}: ${ratio}%` : `${dateStr}: No data`;
                }

                let tooltipText = ratio !== null ? `${dateStr}: ${ratio}%\n\n` : `${dateStr}: No data\n\n`;

                logs.forEach(log => {
                    const logType = parseInt(log.type);
                    const startTime = new Date(parseInt(log.datetime) * 1000);
                    const duration = parseInt(log.duration || 0);

                    const timeStr = this._formatDateTime(startTime);

                    if (duration > 0) {
                        const durationText = this._formatDuration(duration);
                        tooltipText += `${timeStr} (${durationText})`;
                    } else {
                        tooltipText += `${timeStr}`;
                    }

                    if (log.reason && log.reason.detail) {
                        tooltipText += ` - ${log.reason.detail}`;
                    }
                    tooltipText += '\n';
                });

                return tooltipText.trim();
            }

            /**
            * Format duration in human readable format
            */
            static _formatDuration(seconds) {
                if (seconds < 60) return `${seconds} Seconds`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)} Minutes`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)} Hours`;
                return `${Math.floor(seconds / 86400)} Days`;
            }

            /**
            * Create uptime grid chart
            */
            static _createUptimeGrid(monitor) {
                const days = Number(this._opts.uptimeDays) || 90;

                // Try to get custom uptime ratio data
                let ratiosRaw = monitor.custom_uptime_ranges ||
                    monitor.custom_uptime_ratio ||
                    monitor.custom_uptime_ratios ||
                    monitor.custom_uptime_ratio_list ||
                    monitor.customuptimeratios ||
                    monitor.customuptimeratio;

                let ratiosArr = [];
                if (ratiosRaw != null) {
                    if (Array.isArray(ratiosRaw)) {
                        ratiosArr = ratiosRaw.slice();
                    } else if (typeof ratiosRaw === 'string') {
                        // UptimeRobot API returns custom_uptime_ranges as dash-separated string
                        ratiosArr = ratiosRaw.split('-').map(s => s.trim()).filter(s => s !== '');
                    } else {
                        ratiosArr = [String(ratiosRaw)];
                    }
                }

                // Generate recent N days data
                const gridData = [];
                const today = new Date();

                // Get monitor creation date for determining if data should exist
                let monitorCreateDate = null;
                if (monitor.create_datetime) {
                    monitorCreateDate = new Date(monitor.create_datetime * 1000); // Convert Unix timestamp to Date
                }

                // Get logs data
                const logs = monitor.logs || [];

                for (let i = days - 1; i >= 0; i--) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);

                    const dayData = {
                        date: date,
                        dateStr: this._formatDateTime(date, false),
                        ratio: null,
                        status: 'empty'
                    };

                    // Check if this day is before monitor creation date
                    const isBeforeCreation = monitorCreateDate && date < monitorCreateDate;

                    // Process logs for this specific day
                    const dayStart = new Date(date);
                    dayStart.setHours(0, 0, 0, 0);
                    const dayEnd = new Date(date);
                    dayEnd.setHours(23, 59, 59, 999);

                    const dayLogs = this._processLogsForDate(logs, dayStart, dayEnd);
                    dayData.logs = dayLogs;

                    // If has corresponding data
                    // Both time ranges request and returned data are ordered from oldest to newest
                    // So we can directly map: ratiosArr[0] = oldest day, ratiosArr[days-1] = newest day
                    const dayIndex = days - 1 - i; // Direct mapping to ratiosArr index
                    if (dayIndex >= 0 && dayIndex < ratiosArr.length) {
                        const rawRatio = ratiosArr[dayIndex];
                        if (rawRatio != null && rawRatio !== '') {
                            const ratio = parseFloat(String(rawRatio));
                            if (!isNaN(ratio)) {
                                dayData.ratio = ratio;
                                if (ratio >= 99.9) {
                                    dayData.status = 'up';
                                } else if (ratio > 0) {
                                    dayData.status = 'partial';
                                } else if (ratio === 0) {
                                    // 0% could mean downtime or no data, check creation date
                                    if (isBeforeCreation) {
                                        dayData.status = 'empty';
                                        dayData.ratio = null; // Clear ratio for before creation dates
                                    } else {
                                        dayData.status = 'down';
                                    }
                                }
                            } else if (isBeforeCreation) {
                                // Non-numeric data before creation = no data
                                dayData.status = 'empty';
                            }
                        } else if (isBeforeCreation) {
                            // Empty data before creation = no data
                            dayData.status = 'empty';
                        }
                    } else if (isBeforeCreation) {
                        // No data in array and before creation = no data
                        dayData.status = 'empty';
                    }

                    gridData.push(dayData);
                }

                console.debug(gridData)
                // Generate grid HTML with enhanced tooltips
                const cells = gridData.map(day => {
                    const tooltip = this._formatLogTooltip(day.logs, day.dateStr, day.ratio);
                    const escapedTooltip = this._escapeHtml(tooltip);

                    return `<div class="nrc-uptime-cell day-${day.status}" data-tooltip="${escapedTooltip}"></div>`;
                }).join('');

                // Calculate statistics
                const validDays = gridData.filter(d => d.ratio !== null);
                const avgUptime = validDays.length > 0
                    ? (validDays.reduce((sum, d) => sum + d.ratio, 0) / validDays.length).toFixed(2)
                    : 'N/A';

                // Get monitor status information
                const status = this._mapStatus(monitor.status);
                const statusClass = `status-${status}`;
                const statusText = status === 'up' ? 'UP' : status === 'down' ? 'DOWN' : status === 'paused' ? 'PAUSED' : 'UNKNOWN';

                // Check if URL starts with http for link icon
                const hasValidUrl = monitor.url && monitor.url.toLowerCase().startsWith('http');
                const linkIcon = hasValidUrl ? `
                    <a href="${monitor.url}" target="_blank" rel="noopener" class="nrc-uptime-service-link" title="Open ${monitor.url}">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                        </svg>
                    </a>
                ` : '';

                const gridHtml = `
                    <div class="nrc-uptime-grid-section">
                        <div class="nrc-uptime-grid-header">
                            <div class="nrc-uptime-grid-header-left">
                                <div class="nrc-uptime-badge ${statusClass}">${statusText}</div>
                                <h3 class="nrc-uptime-service-name">
                                    <span>${this._escapeHtml(monitor.friendly_name || monitor.url || 'Monitor')}</span>
                                    ${linkIcon}
                                </h3>
                            </div>
                            <div class="nrc-uptime-grid-header-right">
                                <div class="nrc-uptime-availability">
                                    <div class="nrc-uptime-availability-value">${avgUptime}${avgUptime !== 'N/A' ? '%' : ''}</div>
                                </div>
                            </div>
                        </div>
                        <div class="nrc-uptime-grid">${cells}</div>
                        <div class="nrc-uptime-grid-footer">
                            <div class="nrc-uptime-grid-footer-left">
                                <span class="nrc-uptime-time-label">${days} days ago</span>
                            </div>
                            <div class="nrc-uptime-grid-footer-right">
                                <div class="nrc-uptime-grid-legend">
                                    <div class="nrc-uptime-grid-legend-item">
                                        <div class="nrc-uptime-grid-legend-color" style="background-color: #10b981;"></div>
                                        <span>Up</span>
                                    </div>
                                    <div class="nrc-uptime-grid-legend-item">
                                        <div class="nrc-uptime-grid-legend-color" style="background-color: #f59e0b;"></div>
                                        <span>Partial</span>
                                    </div>
                                    <div class="nrc-uptime-grid-legend-item">
                                        <div class="nrc-uptime-grid-legend-color" style="background-color: #ef4444;"></div>
                                        <span>Down</span>
                                    </div>
                                    <div class="nrc-uptime-grid-legend-item">
                                        <div class="nrc-uptime-grid-legend-color" style="background-color: #e5e7eb;"></div>
                                        <span>No data</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                return { gridHtml };
            }

            /**
            * Initialize tooltip
            */
            static _initTooltips(container) {
                // Find or create tooltip element
                let tooltip = document.getElementById('nrc-uptime-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'nrc-uptime-tooltip';
                    tooltip.className = 'nrc-uptime-tooltip';
                    document.body.appendChild(tooltip);
                }

                const cells = container.querySelectorAll('.nrc-uptime-cell[data-tooltip]');

                cells.forEach(cell => {
                    // Remove old event listeners if any
                    const newCell = cell.cloneNode(true);
                    cell.parentNode.replaceChild(newCell, cell);

                    // Add new event listeners
                    newCell.addEventListener('mouseenter', (e) => {
                        const text = e.target.getAttribute('data-tooltip');
                        // Unescape HTML entities for proper display
                        const unescapedText = this._unescapeHtml(text);
                        tooltip.textContent = unescapedText;
                        tooltip.classList.add('show');
                    });

                    newCell.addEventListener('mousemove', (e) => {
                        const rect = tooltip.getBoundingClientRect();
                        let left = e.clientX - rect.width / 2;
                        let top = e.clientY - rect.height - 10;

                        // Ensure tooltip stays within viewport
                        const padding = 10;
                        left = Math.max(padding, Math.min(left, window.innerWidth - rect.width - padding));
                        top = Math.max(padding, top);

                        tooltip.style.left = left + 'px';
                        tooltip.style.top = top + 'px';
                    });

                    newCell.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('show');
                    });
                });
            }

            /**
            * Map status code to status name
            */
            static _mapStatus(statusCode) {
                const code = Number(statusCode);
                switch (code) {
                    case 2: return 'up';
                    case 8:
                    case 9: return 'down';
                    case 0: return 'paused';
                    default: return 'unknown';
                }
            }

            /**
            * HTML escape
            */
            static _escapeHtml(unsafe) {
                if (!unsafe && unsafe !== 0) return '';
                return String(unsafe).replace(/[&<>"']/g, function (char) {
                    const escapeMap = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    };
                    return escapeMap[char];
                });
            }

            /**
            * HTML unescape
            */
            static _unescapeHtml(escaped) {
                if (!escaped && escaped !== 0) return '';
                return String(escaped).replace(/&amp;|&lt;|&gt;|&quot;|&#39;/g, function (entity) {
                    const unescapeMap = {
                        '&amp;': '&',
                        '&lt;': '<',
                        '&gt;': '>',
                        '&quot;': '"',
                        '&#39;': "'"
                    };
                    return unescapeMap[entity];
                });
            }

            /**
            * Render error message
            */
            static _renderError(message) {
                const container = this._resolveContainer(this._opts.container || 'body');
                if (!container) return;

                container.innerHTML = `<div class="nrc-uptime-error">${this._escapeHtml(message)}</div>`;
            }

            /**
            * Initialize responsive grid
            */
            static _initResponsiveGrid(container) {
                const grids = container.querySelectorAll('.nrc-uptime-grid');
                if (grids.length === 0) return;

                // Grid adjustment function
                const adjustGrids = () => {
                    grids.forEach(grid => {
                        const cells = grid.querySelectorAll('.nrc-uptime-cell');
                        if (cells.length === 0) return;

                        const containerWidth = grid.offsetWidth;
                        const totalCells = cells.length;
                        const isMobile = window.innerWidth <= 768;
                        const gap = isMobile ? 2 : 3;
                        const minCellWidth = 8;
                        const cellHeight = 24;

                        // Calculate minimum rows needed: based on minimum cell size and total cells
                        // If one row can fit all cells (based on minimum size), use one row
                        const minRequiredWidthForOneRow = totalCells * minCellWidth + (totalCells - 1) * gap;

                        let cols, rows;
                        if (containerWidth >= minRequiredWidthForOneRow) {
                            // Container is wide enough, display all cells in one row
                            cols = totalCells;
                            rows = 1;
                        } else {
                            // Container not wide enough, need multiple rows
                            // Find optimal column count, so each row has same number of cells with no empty cells
                            cols = 1;
                            rows = totalCells;

                            // Start from maximum possible columns, find column count that divides total cells evenly
                            const maxCellsPerRow = Math.floor((containerWidth + gap) / (minCellWidth + gap));

                            for (let testCols = Math.min(maxCellsPerRow, totalCells); testCols >= 1; testCols--) {
                                // Check if divisible evenly (no remaining cells)
                                if (totalCells % testCols === 0) {
                                    const testCellSize = Math.floor((containerWidth - (testCols - 1) * gap) / testCols);

                                    // Check if cell size meets minimum requirement
                                    if (testCellSize >= minCellWidth) {
                                        cols = testCols;
                                        rows = totalCells / testCols;
                                        break;
                                    }
                                }
                            }

                            // If no evenly divisible column count found, choose closest, but this will result in fewer cells in last row
                            if (cols === 1 && rows === totalCells) {
                                cols = Math.max(maxCellsPerRow, 1);
                                rows = Math.ceil(totalCells / cols);
                            }
                        }

                        // Calculate actual cell size: make each row fill the width
                        const actualCellSize = Math.floor((containerWidth - (cols - 1) * gap) / cols);
                        const finalCellSize = Math.max(actualCellSize, minCellWidth);

                        // Rebuild grid HTML, grouped by rows
                        let newGridHTML = '';

                        for (let row = 0; row < rows; row++) {
                            const rowStartIndex = row * cols;
                            const rowEndIndex = Math.min(rowStartIndex + cols, totalCells);
                            const actualCellsInRow = rowEndIndex - rowStartIndex;

                            // Each row displays actual number of cells, no placeholders
                            const cellsToShow = actualCellsInRow;

                            // Calculate cell width and spacing for this row to fill container width
                            let actualCellWidth = finalCellSize;
                            let actualGap = gap;

                            if (cellsToShow > 1) {
                                // Calculate remaining space and distribute to cell width
                                const totalGaps = cellsToShow - 1;
                                const usedSpaceByGaps = totalGaps * gap;
                                const remainingSpace = containerWidth - usedSpaceByGaps;
                                actualCellWidth = Math.floor(remainingSpace / cellsToShow);

                                // If there are remaining pixels, allocate to spacing
                                const actualUsedSpace = actualCellWidth * cellsToShow + usedSpaceByGaps;
                                const extraPixels = containerWidth - actualUsedSpace;
                                if (extraPixels > 0 && totalGaps > 0) {
                                    actualGap = gap + Math.floor(extraPixels / totalGaps);
                                }
                            } else {
                                // When only one cell, fill the entire container width
                                actualCellWidth = containerWidth;
                            }

                            // Create a sub-grid for each row
                            let rowHTML = `<div class="nrc-uptime-grid-row" style="display: flex; justify-content: space-between; margin-bottom: ${row === rows - 1 ? 0 : gap}px; width: 100%;">`;

                            for (let i = 0; i < cellsToShow; i++) {
                                const cellIndex = rowStartIndex + i;
                                const isLastInRow = i === cellsToShow - 1;
                                const marginRight = isLastInRow ? 0 : actualGap;

                                // Only render actually existing cells
                                const cell = cells[cellIndex];
                                if (cell) {
                                    rowHTML += `<div class="${cell.className}" data-tooltip="${cell.getAttribute('data-tooltip')}" style="width: ${actualCellWidth}px; height: ${cellHeight}px; border-radius: 3px; cursor: pointer; transition: transform 0.1s ease; position: relative; flex-shrink: 0; margin-right: ${marginRight}px;"></div>`;
                                }
                            }

                            rowHTML += '</div>';
                            newGridHTML += rowHTML;
                        }

                        // Replace original grid content
                        grid.innerHTML = newGridHTML;

                        // Reset grid styles
                        grid.style.display = 'block';
                        grid.style.gap = '0';

                        // Reinitialize tooltips for newly generated cells
                        requestAnimationFrame(() => {
                            this._initTooltips(container);
                        });
                    });
                };

                // Initial adjustment - use requestAnimationFrame for smoother rendering
                requestAnimationFrame(adjustGrids);

                // Listen for window size changes
                if (!this._resizeHandler) {
                    this._resizeHandler = () => {
                        requestAnimationFrame(adjustGrids);
                    };
                    window.addEventListener('resize', this._resizeHandler);
                }

                // Use ResizeObserver to monitor container size changes (if supported)
                if (window.ResizeObserver && !this._resizeObserver) {
                    this._resizeObserver = new ResizeObserver(() => {
                        requestAnimationFrame(adjustGrids);
                    });

                    grids.forEach(grid => {
                        this._resizeObserver.observe(grid.parentElement || grid);
                    });
                }
            }
        }

    </script>
</head>

<body>

</body>

</html>

<script>
    nrcUptimeRobot.init({
        apiKey: "ur706089-b1a282befbc5978c665b4fbf",
        title: document.title,
        hideKeywordMonitoring: ["oss"],
    });
</script>